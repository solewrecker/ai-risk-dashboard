<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Risk Assessment Report</title>
    <style>:root {
  --risk-color: #3b82f6;
  --risk-degrees: 180deg;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  color: #1e293b;
  background: #f8fafc;
  font-family: Inter, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
  line-height: 1.6;
}

.report-container {
  background: #fff;
  max-width: 1200px;
  margin: 0 auto;
  box-shadow: 0 4px 6px -1px #0000001a;
}

.header {
  color: #fff;
  background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
  padding: 3rem 2rem;
  position: relative;
  overflow: hidden;
}

.header:before {
  content: "";
  background: #ffffff1a;
  border-radius: 50%;
  width: 200px;
  height: 200px;
  position: absolute;
  top: 0;
  right: 0;
  transform: translate(50px, -50px);
}

.header-content {
  z-index: 2;
  text-align: center;
  position: relative;
}

.report-title {
  letter-spacing: -.025em;
  margin-bottom: .5rem;
  font-size: 2.5rem;
  font-weight: 800;
}

.report-subtitle {
  opacity: .9;
  margin-bottom: 1.5rem;
  font-size: 1.25rem;
  font-weight: 300;
}

.tool-highlight {
  background: #ffffff26;
  border-radius: 8px;
  margin: 1.5rem 0;
  padding: 1rem;
}

.tool-highlight .tool-name {
  margin-bottom: .25rem;
  font-size: 1.75rem;
  font-weight: 700;
}

.tool-highlight .tool-subtitle {
  opacity: .9;
  font-size: 1rem;
}

.report-meta {
  border-top: 1px solid #fff3;
  justify-content: space-between;
  align-items: center;
  margin-top: 2rem;
  padding-top: 2rem;
  font-size: .9rem;
  display: flex;
}

.executive-summary {
  background: #fff;
  border-bottom: 1px solid #e2e8f0;
  padding: 2rem;
}

.summary-header {
  margin-bottom: 2rem;
}

.section-title {
  color: #1e293b;
  align-items: center;
  gap: .5rem;
  margin-bottom: 1rem;
  font-size: 1.5rem;
  font-weight: 700;
  display: flex;
}

.summary-grid {
  grid-template-columns: auto 1fr;
  align-items: center;
  gap: 3rem;
  margin-bottom: 2rem;
  display: grid;
}

.risk-score-display {
  background: linear-gradient(135deg, var(--risk-color, #3b82f6) 0%, var(--risk-color-light, #60a5fa) 100%);
  text-align: center;
  color: #fff;
  border-radius: 16px;
  min-width: 250px;
  padding: 2rem;
  box-shadow: 0 8px 24px #00000026;
}

.risk-score-number {
  margin-bottom: .5rem;
  font-size: 4rem;
  font-weight: 800;
  line-height: 1;
}

.risk-score-total {
  opacity: .9;
  margin-bottom: 1rem;
  font-size: 1.1rem;
}

.risk-level-badge {
  color: #fff;
  text-transform: uppercase;
  letter-spacing: .1em;
  backdrop-filter: blur(10px);
  background: #fff3;
  border-radius: 25px;
  margin-bottom: 1rem;
  padding: .75rem 1.5rem;
  font-size: 1rem;
  font-weight: 700;
  display: inline-block;
}

.risk-description {
  color: #ffffffe6;
  font-size: 1rem;
  line-height: 1.5;
}

.risk-low {
  --risk-color: #10b981;
  --risk-color-light: #34d399;
}

.risk-medium {
  --risk-color: #f59e0b;
  --risk-color-light: #fbbf24;
}

.risk-high {
  --risk-color: #ef4444;
  --risk-color-light: #f87171;
}

.risk-critical {
  --risk-color: #dc2626;
  --risk-color-light: #ef4444;
}

.summary-insights {
  flex-direction: column;
  gap: 1rem;
  display: flex;
}

.insight-card {
  background: #f8fafc;
  border-left: 4px solid #3b82f6;
  border-radius: 8px;
  padding: 1.5rem;
}

.insight-title {
  color: #1e40af;
  text-transform: uppercase;
  letter-spacing: .05em;
  margin-bottom: .5rem;
  font-size: .9rem;
  font-weight: 600;
}

.insight-text {
  color: #64748b;
  font-size: .95rem;
}

.key-findings {
  background: #fef3c7;
  border: 1px solid #f59e0b;
  border-radius: 8px;
  margin-top: 1.5rem;
  padding: 1.5rem;
}

.findings-title {
  color: #92400e;
  align-items: center;
  gap: .5rem;
  margin-bottom: 1rem;
  font-weight: 700;
  display: flex;
}

.findings-list {
  color: #92400e;
  padding-left: 0;
  font-size: .9rem;
  line-height: 1.6;
  list-style-type: none;
}

.tool-info-section {
  background: #f8fafc;
  padding: 2rem;
}

.tool-card {
  background: #fff;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 1px 3px #0000001a;
}

.tool-header {
  align-items: center;
  gap: 1rem;
  margin-bottom: 2rem;
  display: flex;
}

.tool-icon {
  color: #fff;
  background: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%);
  border-radius: 12px;
  justify-content: center;
  align-items: center;
  width: 60px;
  height: 60px;
  font-size: 1.5rem;
  font-weight: bold;
  display: flex;
}

.tool-details {
  flex: 1;
}

.tool-name {
  color: #1e293b;
  margin-bottom: .25rem;
  font-size: 1.5rem;
  font-weight: 700;
}

.tool-category {
  color: #64748b;
  font-size: .9rem;
}

.info-grid {
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
  display: grid;
}

.info-item {
  background: #f8fafc;
  border-left: 3px solid #e2e8f0;
  border-radius: 8px;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  display: flex;
}

.info-label {
  color: #374151;
  font-size: .9rem;
  font-weight: 600;
}

.info-value {
  color: #1f2937;
  font-weight: 500;
}

.info-value.critical {
  color: #dc2626;
  font-weight: 700;
}

.permissions-section {
  padding: 2rem;
}

.permissions-card {
  background: #fff;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 1px 3px #0000001a;
}

.permissions-grid {
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
  display: grid;
}

.permission-item {
  text-align: center;
  border: 2px solid;
  border-radius: 8px;
  padding: 1rem;
  transition: all .3s;
}

.permission-item.granted {
  color: #166534;
  background: #dcfce7;
  border-color: #16a34a;
}

.permission-item.limited {
  color: #92400e;
  background: #fef3c7;
  border-color: #f59e0b;
}

.permission-item.denied {
  color: #991b1b;
  background: #fecaca;
  border-color: #dc2626;
}

.permission-title {
  margin-bottom: .25rem;
  font-size: .9rem;
  font-weight: 600;
}

.permission-status {
  text-transform: uppercase;
  letter-spacing: .5px;
  font-size: .8rem;
  font-weight: 600;
}

.risk-breakdown {
  padding: 2rem;
}

.categories-grid {
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 2rem;
  display: flex;
}

.category-card {
  background: #fff;
  border-top: 4px solid;
  border-radius: 12px;
  padding: 1.5rem;
  transition: transform .2s, box-shadow .2s;
  box-shadow: 0 1px 3px #0000001a;
}

.category-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px #00000026;
}

.category-card.low {
  border-top-color: #10b981;
}

.category-card.medium {
  border-top-color: #f59e0b;
}

.category-card.high {
  border-top-color: #ef4444;
}

.category-card.critical {
  border-top-color: #dc2626;
}

.category-header {
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  display: flex;
}

.category-name {
  color: #1e293b;
  flex: 1;
  font-weight: 600;
}

.category-score {
  border-radius: 20px;
  margin-left: 1rem;
  padding: .5rem 1rem;
  font-size: .9rem;
  font-weight: 700;
}

.category-score.low {
  color: #166534;
  background: #dcfce7;
}

.category-score.medium {
  color: #92400e;
  background: #fef3c7;
}

.category-score.high {
  color: #991b1b;
  background: #fecaca;
}

.category-score.critical {
  color: #fff;
  background: #dc2626;
}

.category-description {
  color: #64748b;
  border-top: 1px solid #f1f5f9;
  margin-top: .5rem;
  padding-top: .5rem;
  font-size: .9rem;
  line-height: 1.6;
}

.risk-matrix-section {
  background: #f8fafc;
  padding: 2rem;
}

.matrix-container {
  background: #fff;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 1px 3px #0000001a;
}

.matrix-table {
  border-collapse: collapse;
  border-radius: 8px;
  width: 100%;
  margin: 1rem 0;
  overflow: hidden;
  box-shadow: 0 1px 3px #0000001a;
}

.matrix-table th, .matrix-table td {
  text-align: center;
  border: 1px solid #e2e8f0;
  padding: 1rem;
  font-size: .9rem;
  font-weight: 600;
}

.matrix-table th {
  color: #fff;
  background: #1e40af;
}

.matrix-low {
  color: #166534;
  background: #dcfce7;
}

.matrix-medium {
  color: #92400e;
  background: #fef3c7;
}

.matrix-high {
  color: #991b1b;
  background: #fecaca;
}

.matrix-critical {
  color: #fff;
  background: #dc2626;
}

.current-risk {
  font-weight: 800;
  position: relative;
}

.current-risk:after {
  content: "★";
  color: #fbbf24;
  font-size: 1.2rem;
  position: absolute;
  top: 50%;
  right: 10px;
  transform: translateY(-50%);
}

.recommendations-section {
  padding: 2rem;
}

.recommendations-grid {
  gap: 1rem;
  display: grid;
}

.recommendation-card {
  background: #fff;
  border-left: 4px solid;
  border-radius: 12px;
  padding: 1.5rem;
  transition: transform .2s;
  box-shadow: 0 1px 3px #0000001a;
}

.recommendation-card:hover {
  transform: translateX(4px);
}

.recommendation-card.priority-high {
  background: linear-gradient(to right, #fef2f2, #fff);
  border-left-color: #dc2626;
}

.recommendation-card.priority-medium {
  background: linear-gradient(to right, #fef9e7, #fff);
  border-left-color: #f59e0b;
}

.recommendation-card.priority-low {
  background: linear-gradient(to right, #f0fdf4, #fff);
  border-left-color: #16a34a;
}

.recommendation-header {
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  display: flex;
}

.recommendation-title {
  color: #1e293b;
  font-weight: 700;
}

.priority-badge {
  text-transform: uppercase;
  letter-spacing: .05em;
  border-radius: 12px;
  padding: .25rem .75rem;
  font-size: .75rem;
  font-weight: 600;
}

.priority-badge.priority-high {
  color: #fff;
  background: #dc2626;
}

.priority-badge.priority-medium {
  color: #fff;
  background: #f59e0b;
}

.priority-badge.priority-low {
  color: #fff;
  background: #16a34a;
}

.recommendation-text {
  color: #64748b;
  line-height: 1.6;
}

.footer {
  color: #fff;
  text-align: center;
  background: #1e293b;
  padding: 2rem;
}

.confidential-banner {
  text-transform: uppercase;
  letter-spacing: .05em;
  background: #dc2626;
  border-radius: 4px;
  margin-bottom: 1rem;
  padding: .75rem;
  font-weight: 700;
}

.footer-grid {
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 2rem;
  margin-bottom: 1rem;
  display: grid;
}

.footer-section h4 {
  color: #3b82f6;
  margin-bottom: .5rem;
}

.footer-section p {
  opacity: .8;
  font-size: .9rem;
}

@media (width <= 768px) {
  .summary-grid {
    text-align: center;
    grid-template-columns: 1fr;
  }

  .info-grid, .categories-grid, .permissions-grid {
    grid-template-columns: 1fr;
  }

  .report-title {
    font-size: 2rem;
  }

  .risk-score-display {
    min-width: auto;
    padding: 1.5rem;
  }

  .risk-score-number {
    font-size: 3rem;
  }
}

@media print {
  body {
    background: #fff;
  }

  .report-container {
    box-shadow: none;
  }

  .category-card, .recommendation-card {
    page-break-inside: avoid;
  }

  .section-title {
    page-break-after: avoid;
  }

  .risk-matrix-section {
    page-break-before: always;
  }
}
</style>
</head>
<body>
    <div class="report-container">
        <!-- Report Header -->
        <header class="header">
            <div class="header-content">
                <h1 class="report-title">AI Tool Risk Assessment</h1>
                <p class="report-subtitle">Detailed Analysis Report</p>
                <div class="tool-highlight">
                    <div class="tool-name">{{tool_name}}</div>
                </div>
                <div class="report-meta">
                    <div class="meta-item"><strong>Report Date:</strong> <span id="reportDate"></span></div>
                    <div class="meta-item"><strong>Assessed By:</strong> AI Risk Pro</div>
                    </div>
                    </div>
        </header>

        <!-- Executive Summary -->
        <section class="executive-summary">
            <div class="summary-header">
                <h2 class="section-title">Executive Summary</h2>
            </div>
            <div class="summary-grid">
                <div class="risk-score-display risk-{{risk_level}}">
                    <div class="risk-score-number">{{total_score}}</div>
                    <span class="risk-score-total">/ 100</span>
                    <div class="risk-level-badge">{{risk_level}}</div>
                </div>
                <div class="summary-insights">
                    <!-- Insights will be populated here -->
                    </div>
                    </div>
            <div class="key-findings">
                <h3 class="findings-title">Key Recommendations</h3>
                <ul class="findings-list">
                    {{recommendations_list}}
                </ul>
                </div>
        </section>

        <!-- Detailed Breakdown -->
        <section class="detailed-breakdown">
             <!-- Detailed content will be populated here -->
        </section>
                </div>
                
    <script>document.getElementById('reportDate').textContent = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
});

</script>

    <!-- Add Supabase Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <script>// Initialize Supabase (use your existing configuration)
const SUPABASE_URL = 'https://lgybmsziqjdmmxdiyils.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxneWJtc3ppcWpkbW14ZGl5aWxzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA3MTAzOTcsImV4cCI6MjA2NjI4NjM5N30.GFqiwK2qi3TnlUDCmdFZpG69pqdPP-jpbxdUGX6VlSg';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
// Multiplier constants removed - no longer using fallback calculations
// Export-template.html now uses either pre-calculated scores OR raw database scores
// Risk level calculation function for individual categories (using percentage)
function calculateRiskLevel(score, maxScore = 25) {
    if (!score || score === 0) return 'LOW';
    const percentage = score / maxScore * 100;
    if (percentage >= 80) return 'HIGH'; // 80%+ of max score
    if (percentage >= 60) return 'MEDIUM'; // 60-79% of max score  
    return 'LOW'; // < 60% of max score
}
// Get CSS class for risk level
function getRiskLevelClass(riskLevel) {
    switch(riskLevel.toLowerCase()){
        case 'high':
            return 'high';
        case 'medium':
            return 'medium';
        case 'low':
            return 'low';
        default:
            return 'low';
    }
}
// applyMultipliers function removed - no longer using fallback calculations
// All calculations now happen in index.html with actual user selections
// Security category descriptions matching your data structure
const categoryDescriptions = {
    'dataStorage': {
        name: 'Data Storage & Security',
        description: 'Encryption, data residency, and storage practices'
    },
    'trainingUsage': {
        name: 'Training Data Usage',
        description: 'Model training and data utilization policies'
    },
    'accessControls': {
        name: 'Access Controls',
        description: 'Authentication, authorization, and user management'
    },
    'complianceRisk': {
        name: 'Compliance Risk',
        description: 'Regulatory compliance and audit readiness'
    },
    'vendorTransparency': {
        name: 'Vendor Transparency',
        description: 'Documentation, SLAs, and incident response'
    }
};
// Generate detailed breakdown with sub-categories from your data
function generateDescription(categoryKey, score, breakdownData) {
    const baseDesc = categoryDescriptions[categoryKey]?.description || 'Assessment data analysis';
    const riskLevel = calculateRiskLevel(score);
    // Check if this is a free version (embedded data from index.html)
    const isFreeVersion = window.EMBEDDED_TOOL_INFO?.isFreeVersion || false;
    // Handle both camelCase keys (dataStorage) and human-readable keys ("Data Storage & Security")
    const categoryKeyMap = {
        'dataStorage': 'Data Storage & Security',
        'trainingUsage': 'Training Data Usage',
        'accessControls': 'Access Controls',
        'complianceRisk': 'Compliance Risk',
        'vendorTransparency': 'Vendor Transparency'
    };
    console.log(`\u{1F50D} generateDescription called for ${categoryKey}:`, {
        score,
        riskLevel,
        breakdownData: breakdownData,
        hasSubScores: !!(breakdownData && breakdownData.subScores),
        categoryExists: !!(breakdownData && breakdownData.subScores && breakdownData.subScores[categoryKey])
    });
    // DEBUG: Show actual breakdown structure
    if (breakdownData) {
        console.log(`\u{1F50D} Available breakdown keys:`, Object.keys(breakdownData));
        const humanReadableKey = categoryKeyMap[categoryKey];
        console.log(`\u{1F50D} Looking for keys: "${categoryKey}" or "${humanReadableKey}"`);
        console.log(`\u{1F50D} Direct category access: breakdownData["${humanReadableKey}"] =`, breakdownData[humanReadableKey]);
        if (breakdownData.subScores) console.log(`\u{1F50D} subScores keys:`, Object.keys(breakdownData.subScores));
    }
    // Try to extract detailed sub-category notes from your breakdown structure
    const humanReadableKey = categoryKeyMap[categoryKey];
    let targetCategory = null;
    // First try the database format with subScores
    if (breakdownData && breakdownData.subScores) targetCategory = breakdownData.subScores[categoryKey] || breakdownData.subScores[humanReadableKey];
    // If not found, try direct category access (alternative breakdown format)
    if (!targetCategory && breakdownData) targetCategory = breakdownData[categoryKey] || breakdownData[humanReadableKey];
    if (targetCategory) {
        const subCategoryDetails = [];
        console.log(`\u{2705} Found category data for ${categoryKey} (using key: ${targetCategory === breakdownData[humanReadableKey] ? humanReadableKey : categoryKey}):`, targetCategory);
        // Map sub-score keys to readable names
        const subCategoryNames = {
            'retention': "\uD83D\uDCC5 Data Retention",
            'encryption': "\uD83D\uDD12 Encryption",
            'geographic': "\uD83C\uDF0D Geographic Controls",
            'sharing': "\uD83D\uDD04 Data Sharing",
            'training': "\uD83E\uDD16 Training Usage",
            'admin': "\uD83D\uDC65 Admin Controls",
            'audit': "\uD83D\uDCCA Audit & Monitoring",
            'integration': "\uD83D\uDD17 Integration",
            'violations': "\u26A0\uFE0F Compliance Violations",
            'transparency': "\uD83D\uDCCB Policy Transparency",
            'score': "\uD83D\uDCC8 Overall Assessment"
        };
        // Extract and format each sub-category
        Object.keys(targetCategory).forEach((subKey)=>{
            const subItem = targetCategory[subKey];
            // Handle different data structures
            let note = null;
            if (subItem && typeof subItem === 'object' && subItem.note) // Standard structure: {retention: {note: "...", score: 5}}
            note = subItem.note;
            else if (subItem && typeof subItem === 'string') // Simple structure: {retention: "Some note"}
            note = subItem;
            else if (subItem && subItem.description) // Alternative structure: {retention: {description: "..."}}
            note = subItem.description;
            if (note) {
                const displayName = subCategoryNames[subKey] || `\u{1F4CC} ${subKey.charAt(0).toUpperCase() + subKey.slice(1)}`;
                subCategoryDetails.push(`<strong>${displayName}:</strong> ${note}`);
                console.log(`\u{1F4DD} Added note for ${subKey}: ${note.substring(0, 50)}...`);
            }
        });
        if (subCategoryDetails.length > 0) {
            console.log(`\u{2705} Returning ${subCategoryDetails.length} detailed notes for ${categoryKey}`);
            return subCategoryDetails.join('<br><br>');
        } else console.log(`\u{26A0}\u{FE0F} No notes found in category data for ${categoryKey}`);
    } else console.log(`\u{274C} No category data found for ${categoryKey} (tried keys: ${categoryKey}, ${humanReadableKey}). Falling back to generic description.`);
    // Check if there's a details field for this category (from your data structure)
    if (breakdownData && breakdownData.details && breakdownData.details[categoryKey]) return breakdownData.details[categoryKey];
    // Fallback descriptions based on risk level and category
    if (isFreeVersion) // Simplified descriptions for free users
    switch(categoryKey){
        case 'dataStorage':
            return `${getQualitativeRisk(riskLevel)} data storage practices. Key security measures evaluated.`;
        case 'trainingUsage':
            return `${getQualitativeRisk(riskLevel)} training data usage. Model training policies assessed.`;
        case 'accessControls':
            return `${getQualitativeRisk(riskLevel)} access controls. User management and authentication reviewed.`;
        case 'complianceRisk':
            return `${getQualitativeRisk(riskLevel)} compliance assessment. Regulatory alignment evaluated.`;
        case 'vendorTransparency':
            return `${getQualitativeRisk(riskLevel)} vendor practices. Documentation and support reviewed.`;
        default:
            return `${getQualitativeRisk(riskLevel)} assessment completed.`;
    }
    else // Detailed descriptions for enterprise users
    switch(categoryKey){
        case 'dataStorage':
            return `${getQualitativeRisk(riskLevel)} data storage assessment. Encryption, retention, and geographic controls evaluated.`;
        case 'trainingUsage':
            return `${getQualitativeRisk(riskLevel)} training data usage assessment. Model training and data sharing policies reviewed.`;
        case 'accessControls':
            return `${getQualitativeRisk(riskLevel)} access controls assessment. Authentication, authorization, and audit capabilities evaluated.`;
        case 'complianceRisk':
            return `${getQualitativeRisk(riskLevel)} compliance assessment. Regulatory requirements and frameworks reviewed.`;
        case 'vendorTransparency':
            return `${getQualitativeRisk(riskLevel)} vendor transparency assessment. Documentation, support, and transparency evaluated.`;
        default:
            return `${getQualitativeRisk(riskLevel)} assessment for ${baseDesc.toLowerCase()}.`;
    }
}
// Helper function to get qualitative risk description
function getQualitativeRisk(riskLevel) {
    switch(riskLevel){
        case 'HIGH':
            return 'High-risk';
        case 'MEDIUM':
            return 'Medium-risk';
        case 'LOW':
            return 'Low-risk';
        default:
            return 'Standard';
    }
}
// Build search terms using the same logic as index.html
function buildSearchTerms(toolName, toolVersion) {
    const cleanToolName = toolName.trim();
    const searchTerms = [];
    const versionSuffix = toolVersion === 'enterprise' ? 'Enterprise' : 'Free';
    // Check if tool name already includes the version suffix
    const toolNameLower = cleanToolName.toLowerCase();
    const suffixLower = versionSuffix.toLowerCase();
    // PRIORITY 1: Try exact matches with version first
    if (!toolNameLower.includes(suffixLower)) {
        // Try common database naming patterns for the specific version
        searchTerms.push(`${cleanToolName}.ai ${versionSuffix}`); // "Claude.ai Enterprise"
        searchTerms.push(`${cleanToolName} ${versionSuffix}`); // "Claude Enterprise"
        // Try variations of the tool name
        if (cleanToolName.toLowerCase() === 'claude') searchTerms.push(`Claude.ai ${versionSuffix}`);
        else if (cleanToolName.toLowerCase() === 'chatgpt') searchTerms.push(`ChatGPT ${versionSuffix}`);
        else if (cleanToolName.toLowerCase().includes('copilot')) {
            searchTerms.push(`GitHub Copilot ${versionSuffix}`);
            searchTerms.push(`Microsoft Copilot ${versionSuffix}`);
        }
    }
    // PRIORITY 2: Try exact name as entered (only if no version-specific matches)
    searchTerms.push(cleanToolName);
    console.log(`\u{1F50D} [TEMPLATE] Built search terms for "${toolName}" (${toolVersion}):`, searchTerms);
    return searchTerms;
}
// Load security assessment data - use final calculated scores from index.html
async function loadSecurityAssessment() {
    try {
        // PRIORITY 1: Use pre-calculated scores from index.html (no recalculation needed)
        if (window.EMBEDDED_TOOL_INFO && window.EMBEDDED_TOOL_INFO.hasCalculatedScores) {
            console.log("\u2705 Using pre-calculated scores from index.html:", window.EMBEDDED_TOOL_INFO);
            // Build tool data object using final calculated scores
            const toolData1 = {
                name: window.EMBEDDED_TOOL_INFO.toolName || 'Unknown Tool',
                category: window.EMBEDDED_TOOL_INFO.category || 'AI Platform',
                total_score: window.EMBEDDED_TOOL_INFO.finalScore,
                risk_level: window.EMBEDDED_TOOL_INFO.riskLevel?.toLowerCase() || 'low',
                // Use calculated component scores
                data_storage_score: window.EMBEDDED_TOOL_INFO.componentScores?.dataStorage || 0,
                training_usage_score: window.EMBEDDED_TOOL_INFO.componentScores?.trainingUsage || 0,
                access_controls_score: window.EMBEDDED_TOOL_INFO.componentScores?.accessControls || 0,
                compliance_score: window.EMBEDDED_TOOL_INFO.componentScores?.complianceRisk || 0,
                vendor_transparency_score: window.EMBEDDED_TOOL_INFO.componentScores?.vendorTransparency || 0,
                // Pass through any additional data
                breakdown: window.EMBEDDED_TOOL_INFO.breakdown || {}
            };
            console.log("\uD83C\uDFAF Using final calculated scores (no recalculation):", toolData1);
            // Generate all dynamic content using final scores
            generateSecurityCategories(toolData1);
            populateExecutiveSummary(toolData1);
            populateToolInformation(toolData1);
            updateRiskMatrix(toolData1);
            generateAzurePermissions(toolData1);
            generateRecommendations(toolData1);
            return;
        }
        // FALLBACK: Query database if no pre-calculated scores available
        let toolName, toolVersion;
        if (window.EMBEDDED_TOOL_INFO) {
            console.log("\u26A0\uFE0F Found embedded tool info but no calculated scores, querying database");
            toolName = window.EMBEDDED_TOOL_INFO.toolName;
            toolVersion = window.EMBEDDED_TOOL_INFO.toolVersion;
        } else {
            console.log("\u26A0\uFE0F No embedded tool info, trying URL parameters or filename");
            // FALLBACK: Try URL parameters first
            const urlParams = new URLSearchParams(window.location.search);
            toolName = urlParams.get('tool');
            toolVersion = urlParams.get('version') || 'free';
            // If no URL parameters, extract from filename
            if (!toolName) {
                const pathname = window.location.pathname;
                const filename = pathname.split('/').pop();
                console.log("\uD83D\uDD0D Parsing filename:", filename);
                // Extract tool name and version from filename patterns
                if (filename.includes('claude-ai') || filename.includes('claude')) {
                    toolName = 'Claude.ai';
                    toolVersion = filename.includes('enterprise') ? 'enterprise' : 'free';
                    console.log("\u2705 Detected Claude.ai tool, version:", toolVersion);
                } else if (filename.includes('chatgpt')) {
                    toolName = 'ChatGPT';
                    toolVersion = filename.includes('enterprise') ? 'enterprise' : 'free';
                    console.log("\u2705 Detected ChatGPT tool, version:", toolVersion);
                } else if (filename.includes('copilot')) {
                    toolName = 'GitHub Copilot';
                    toolVersion = filename.includes('enterprise') ? 'enterprise' : 'free';
                    console.log("\u2705 Detected Copilot tool, version:", toolVersion);
                } else if (filename.includes('maestro')) {
                    toolName = 'Maestro Labs Notetaker';
                    toolVersion = filename.includes('enterprise') ? 'enterprise' : 'free';
                    console.log("\u2705 Detected Maestro tool, version:", toolVersion);
                } else {
                    toolName = 'ChatGPT';
                    toolVersion = 'free';
                    console.log("\u26A0\uFE0F Using fallback: ChatGPT Free");
                }
            }
        }
        // Now query database with the correct tool name and version
        const searchTerms = buildSearchTerms(toolName, toolVersion);
        console.log("\uD83D\uDD0D Querying database with search terms:", searchTerms);
        for (const searchTerm of searchTerms){
            console.log(`\u{1F50D} [TEMPLATE] Trying search term: "${searchTerm}"`);
            // Use enhanced search logic from index.html
            const orderField = toolVersion === 'enterprise' ? 'name' : 'name';
            const orderDirection = toolVersion === 'enterprise' ? 'desc' : 'asc';
            const { data: tools, error } = await supabase.from('ai_tools').select('*').ilike('name', `%${searchTerm}%`).order(orderField, {
                ascending: orderDirection === 'asc'
            }).limit(3); // Get multiple results to find best match
            if (error) {
                console.warn("\u274C Supabase query error for term:", searchTerm, error);
                continue;
            }
            if (tools && tools.length > 0) {
                console.log(`\u{1F50D} [TEMPLATE] Found ${tools.length} matches:`, tools.map((t)=>`${t.name} (${t.total_score})`));
                // Find the best match for the requested version (same logic as index.html)
                let bestMatch = tools[0]; // Default to first
                for (const tool of tools){
                    const toolNameLower = tool.name.toLowerCase();
                    const requestedVersion = toolVersion.toLowerCase();
                    // Prioritize exact version match
                    if (requestedVersion === 'enterprise' && toolNameLower.includes('enterprise')) {
                        bestMatch = tool;
                        console.log(`\u{2705} [TEMPLATE] ENTERPRISE MATCH FOUND: ${tool.name} (score: ${tool.total_score})`);
                        break;
                    } else if (requestedVersion === 'free' && (toolNameLower.includes('free') || !toolNameLower.includes('enterprise'))) {
                        bestMatch = tool;
                        console.log(`\u{2705} [TEMPLATE] FREE MATCH FOUND: ${tool.name} (score: ${tool.total_score})`);
                        break;
                    }
                }
                toolData = bestMatch;
                console.log(`\u{1F3AF} [TEMPLATE] SELECTED MATCH: ${bestMatch.name} (score: ${bestMatch.total_score})`);
                break;
            }
        }
        if (!toolData) {
            console.warn('No tool data found for search terms:', searchTerms);
            showError(`No assessment data found for: ${searchTerms.join(' or ')}`);
            return;
        }
        console.log("\uD83D\uDCCB Using raw database scores (no multiplier fallback):", toolData);
        // No multiplier calculation - just use raw database scores
        // This is more honest than applying wrong multipliers with hardcoded defaults
        // Generate all dynamic content
        generateSecurityCategories(toolData);
        populateExecutiveSummary(toolData);
        populateToolInformation(toolData);
        updateRiskMatrix(toolData);
        generateAzurePermissions(toolData);
        generateRecommendations(toolData);
    } catch (error) {
        console.error('Error loading security assessment:', error);
        showError('Failed to load security assessment data');
    }
}
// Generate security categories HTML based on your data structure
function generateSecurityCategories(toolData1) {
    const categoriesGrid = document.getElementById('securityCategoriesGrid');
    if (!categoriesGrid) {
        console.error('Categories grid not found');
        return;
    }
    // Extract scores from your data structure
    const scores = {
        dataStorage: toolData1.data_storage_score || 0,
        trainingUsage: toolData1.training_usage_score || 0,
        accessControls: toolData1.access_controls_score || 0,
        complianceRisk: toolData1.compliance_score || 0,
        vendorTransparency: toolData1.vendor_transparency_score || 0
    };
    // Parse breakdown data (your JSON structure)
    let breakdownData = null;
    try {
        if (toolData1.breakdown && typeof toolData1.breakdown === 'string') breakdownData = JSON.parse(toolData1.breakdown);
        else if (toolData1.breakdown && typeof toolData1.breakdown === 'object') breakdownData = toolData1.breakdown;
    } catch (e) {
        console.warn('Could not parse breakdown data:', e);
    }
    console.log('Scores extracted:', scores);
    console.log('Breakdown data:', breakdownData);
    // Generate HTML for each category
    let categoriesHTML = '';
    Object.keys(scores).forEach((categoryKey)=>{
        const score = scores[categoryKey];
        const riskLevel = calculateRiskLevel(score);
        const riskClass = getRiskLevelClass(riskLevel);
        const categoryInfo = categoryDescriptions[categoryKey];
        const description = generateDescription(categoryKey, score, breakdownData);
        categoriesHTML += `
                    <div class="category-card ${riskClass}">
                        <div class="category-header">
                            <div class="category-name">${categoryInfo.name}</div>
                            <div class="category-score ${riskClass}">${riskLevel}</div>
                        </div>
                        <div class="category-description">
                            ${description}
                        </div>
                    </div>
                `;
    });
    // Update the grid
    categoriesGrid.innerHTML = categoriesHTML;
    console.log('Security categories generated successfully');
}
// Populate Executive Summary section
function populateExecutiveSummary(toolData1) {
    const totalScore = toolData1.total_score || 0;
    const riskLevel = getRiskLevelFromScore(totalScore);
    // Update risk score display
    document.getElementById('riskScore').textContent = totalScore;
    document.getElementById('riskLevel').textContent = `${riskLevel} RISK`;
    document.getElementById('riskDescription').textContent = getRiskDescription(riskLevel, totalScore);
    // Apply risk level styling to the card
    const riskCard = document.getElementById('riskScoreCard');
    if (riskCard) {
        // Remove any existing risk classes
        riskCard.classList.remove('risk-low', 'risk-medium', 'risk-high', 'risk-critical');
        // Add the appropriate risk class
        riskCard.classList.add(`risk-${riskLevel.toLowerCase()}`);
    }
    // Generate Security Status
    const securityStatus = generateSecurityStatus(toolData1, riskLevel);
    document.getElementById('securityStatusText').textContent = securityStatus;
    // Generate Compliance Impact
    const complianceImpact = generateComplianceImpact(toolData1);
    document.getElementById('complianceImpactText').textContent = complianceImpact;
    // Generate Main Recommendation
    const mainRecommendation = generateMainRecommendation(toolData1, riskLevel);
    document.getElementById('mainRecommendationText').textContent = mainRecommendation;
    // Generate Key Findings
    const keyFindings = generateKeyFindings(toolData1);
    document.getElementById('keyFindings').innerHTML = keyFindings;
    console.log('Executive summary populated successfully');
}
// Populate Tool Information section
function populateToolInformation(toolData1) {
    const currentDate = new Date().toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });
    // Header information
    document.getElementById('headerToolName').textContent = toolData1.name || 'Unknown Tool';
    const assessmentId = `ASS-${Date.now()}`;
    document.getElementById('headerAssessmentId').textContent = assessmentId;
    document.getElementById('headerGeneratedDate').textContent = currentDate;
    // Footer information
    document.getElementById('footerAssessmentId').textContent = assessmentId;
    document.getElementById('footerGeneratedDate').textContent = currentDate;
    // Next review date (3 months from now)
    const nextReview = new Date();
    nextReview.setMonth(nextReview.getMonth() + 3);
    document.getElementById('nextReviewDate').textContent = nextReview.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });
    // Tool name and category
    document.getElementById('toolName').textContent = toolData1.name || 'Unknown Tool';
    document.getElementById('toolCategory').textContent = toolData1.category || 'AI Platform';
    // Generate tool icon from name
    const toolIcon = generateToolIcon(toolData1.name);
    document.getElementById('toolIcon').textContent = toolIcon;
    // Tool information
    document.getElementById('primaryUseCase').textContent = 'Enterprise Productivity'; // Default - we'll add to DB later
    document.getElementById('dataClassification').textContent = 'Confidential'; // Default - we'll add to DB later
    document.getElementById('assessmentDate').textContent = currentDate;
    document.getElementById('riskCategory').textContent = toolData1.category || 'AI Platform';
    document.getElementById('vendor').textContent = extractVendor(toolData1.name);
    document.getElementById('licenseType').textContent = toolData1.name.includes('Enterprise') ? 'Enterprise License' : 'Standard License';
    console.log('Tool information populated successfully');
}
// Update risk matrix display
function updateRiskMatrix(toolData1) {
    const totalScore = toolData1.total_score || 0;
    const riskLevel = getRiskLevelFromScore(totalScore);
    // Update matrix description
    document.getElementById('matrixDescription').textContent = `\u{2605} Current Risk Level: Score ${totalScore} falls in ${riskLevel} category`;
    // Update current risk cell highlighting (you can enhance this logic)
    const matrixCell = document.getElementById('currentRiskMatrixCell');
    if (matrixCell) {
        // Remove any existing classes and add current risk indicator
        matrixCell.className = `matrix-${riskLevel.toLowerCase()}`;
        matrixCell.innerHTML = `${riskLevel.toLowerCase().charAt(0).toUpperCase() + riskLevel.toLowerCase().slice(1)} \u{2605}`;
    }
    console.log('Risk matrix updated successfully');
}
// Generate Azure permissions (placeholder for now)
function generateAzurePermissions(toolData1) {
    const permissionsHTML = `
                <div style="text-align: center; padding: 2rem; color: #64748b;">
                    <div style="margin-bottom: 1rem;">\u{1F510} Azure AD Integration Assessment</div>
                    <div style="font-size: 0.9rem;">
                        This section will be populated with Azure AD permissions analysis<br>
                        when integration is configured. Contact IT Security for setup.
                    </div>
                </div>
            `;
    document.getElementById('azurePermissions').innerHTML = permissionsHTML;
    console.log('Azure permissions section updated');
}
// Generate recommendations based on tool data
function generateRecommendations(toolData1) {
    const recommendations = [];
    const totalScore = toolData1.total_score || 0;
    const riskLevel = getRiskLevelFromScore(totalScore);
    // Generate recommendations based on scores and risk levels
    if (toolData1.compliance_score > 10) recommendations.push({
        title: 'PCI-DSS Compliance Verification',
        priority: 'HIGH',
        icon: "\uD83D\uDCB3",
        description: 'Conduct comprehensive PCI-DSS compliance audit to ensure financial data handling meets regulatory requirements. Verify data encryption, access logging, and secure transmission protocols.',
        timeline: '30 days',
        owner: 'Security Team'
    });
    if (toolData1.compliance_score > 8) recommendations.push({
        title: 'SOX Controls Implementation',
        priority: 'HIGH',
        icon: "\uD83D\uDCCA",
        description: 'Implement Sarbanes-Oxley controls for financial reporting data processed through the AI tool. Establish audit trails, data integrity checks, and access accountability measures.',
        timeline: '45 days',
        owner: 'Compliance Team'
    });
    if (toolData1.data_storage_score > 8) recommendations.push({
        title: 'Enhanced Data Loss Prevention (DLP)',
        priority: 'MEDIUM',
        icon: "\uD83D\uDEE1\uFE0F",
        description: 'Configure advanced DLP policies to monitor and prevent sensitive data from being inadvertently shared through AI interactions.',
        timeline: '60 days',
        owner: 'IT Security'
    });
    if (riskLevel === 'HIGH' || riskLevel === 'MEDIUM') recommendations.push({
        title: 'AI Governance Committee',
        priority: 'MEDIUM',
        icon: "\uD83D\uDC65",
        description: 'Create a cross-functional AI governance committee to oversee AI tool usage, establish usage policies, and conduct regular risk assessments.',
        timeline: '90 days',
        owner: 'Executive Team'
    });
    recommendations.push({
        title: 'Usage Analytics Dashboard',
        priority: 'LOW',
        icon: "\uD83D\uDCC8",
        description: 'Deploy comprehensive usage analytics to track AI tool utilization patterns, identify potential security anomalies, and generate compliance reports.',
        timeline: '120 days',
        owner: 'IT Operations'
    });
    // Generate HTML for recommendations
    const recommendationsHTML = recommendations.map((rec)=>`
                <div class="recommendation-card priority-${rec.priority.toLowerCase()}">
                    <div class="recommendation-header">
                        <div class="recommendation-title">${rec.title}</div>
                        <div class="priority-badge priority-${rec.priority.toLowerCase()}">${rec.priority}</div>
                    </div>
                    <div class="recommendation-text">
                        ${rec.icon} ${rec.description}
                        <br><br><strong>Timeline:</strong> ${rec.timeline} | <strong>Owner:</strong> ${rec.owner}
                    </div>
                </div>
            `).join('');
    document.getElementById('recommendationsGrid').innerHTML = recommendationsHTML;
    console.log('Recommendations generated successfully');
}
// Helper functions - Updated to match your risk framework
function getRiskLevelFromScore(score) {
    if (score >= 80) return 'CRITICAL';
    if (score >= 60) return 'HIGH';
    if (score >= 35) return 'MEDIUM';
    return 'LOW'; // 0-34 points
}
function getRiskDescription(riskLevel, score) {
    switch(riskLevel){
        case 'CRITICAL':
            return 'Immediate blocking required - critical security risks identified';
        case 'HIGH':
            return 'Significant controls needed before use - high security risks';
        case 'MEDIUM':
            return 'Standard enterprise controls required - moderate security risks';
        case 'LOW':
        default:
            return 'Basic monitoring sufficient - acceptable risk level';
    }
}
function generateSecurityStatus(toolData1, riskLevel) {
    if (riskLevel === 'HIGH' || riskLevel === 'CRITICAL') return 'Tool poses significant security risks requiring immediate attention and enhanced controls before deployment.';
    else if (riskLevel === 'MEDIUM') return 'Tool meets basic security standards with some areas requiring attention for enterprise deployment.';
    else return 'Tool demonstrates acceptable security posture with standard enterprise controls and monitoring.';
}
function generateComplianceImpact(toolData1) {
    const complianceScore = toolData1.compliance_score || 0;
    if (complianceScore > 15) return 'Significant compliance gaps identified. HIPAA, PCI-DSS, and SOX verification required before handling regulated data.';
    else if (complianceScore > 8) return 'PCI-DSS and SOX compliance verification needed due to financial data classification and regulatory requirements.';
    else return 'Standard compliance controls applicable. Regular compliance monitoring and documentation recommended.';
}
function generateMainRecommendation(toolData1, riskLevel) {
    if (riskLevel === 'HIGH' || riskLevel === 'CRITICAL') return 'Immediate security review and remediation required before deployment authorization.';
    else if (riskLevel === 'MEDIUM') return 'Implement enhanced monitoring and compliance controls before full deployment.';
    else return 'Standard deployment procedures with ongoing monitoring and periodic risk assessments.';
}
function generateKeyFindings(toolData1) {
    const findings = [];
    // First, try to use the dedicated summary field from database
    if (toolData1.summary_and_recommendation && toolData1.summary_and_recommendation.trim().length > 0) {
        // Split summary by common separators and add each as a finding
        const summaryFindings = toolData1.summary_and_recommendation.split(/[.।•\n-]/).map((s)=>s.trim()).filter((note)=>note.length > 10); // Filter out very short notes
        findings.push(...summaryFindings.map((finding)=>({
                title: "Key Finding",
                description: finding,
                priority: 'HIGH',
                icon: "\u26A0\uFE0F",
                timeline: 'Immediate',
                owner: 'Security Team'
            })));
    }
    // Fallback: Extract critical findings from breakdown data (NO TRUNCATION)
    if (toolData1.breakdown && toolData1.breakdown.subScores) {
        const subScores = toolData1.breakdown.subScores;
        // Look for critical findings in each category
        Object.keys(subScores).forEach((categoryKey)=>{
            const category = subScores[categoryKey];
            Object.keys(category).forEach((subKey)=>{
                const item = category[subKey];
                if (item && item.note) {
                    const note = item.note.toLowerCase();
                    // Extract critical/important findings based on keywords
                    if (note.includes('critical gap') || note.includes('critical:') || note.includes('hipaa') || note.includes('not compliant') || note.includes('indefinite retention') || note.includes('no enterprise') || note.includes('major compliance barriers') || note.includes('high gdpr risk') || note.includes('no audit trail') || note.includes('basic oauth only') || note.includes('unclear server locations') || note.includes('lacks enterprise-grade')) // Add the full finding WITHOUT truncation
                    findings.push(item.note);
                }
            });
        });
    }
    // If no critical findings found, add general findings based on scores
    if (findings.length === 0) {
        if (toolData1.total_score < 35) {
            findings.push('Acceptable security controls with standard enterprise monitoring requirements');
            findings.push('Regular assessment and compliance review recommended');
        } else {
            findings.push('Enhanced security controls and compliance verification required');
            findings.push('Detailed risk mitigation plan needed before deployment');
        }
    }
    // Limit to top 5 findings (but keep full text)
    const limitedFindings = findings.slice(0, 5);
    return "\u2022 " + limitedFindings.join("<br>\u2022 ");
}
function generateToolIcon(toolName) {
    if (toolName.toLowerCase().includes('chatgpt')) return 'GPT';
    if (toolName.toLowerCase().includes('claude')) return 'CLD';
    if (toolName.toLowerCase().includes('copilot')) return 'CP';
    if (toolName.toLowerCase().includes('gemini')) return 'GEM';
    return 'AI';
}
function extractVendor(toolName) {
    if (toolName.toLowerCase().includes('chatgpt')) return 'OpenAI';
    if (toolName.toLowerCase().includes('claude')) return 'Anthropic';
    if (toolName.toLowerCase().includes('copilot')) return 'Microsoft/GitHub';
    if (toolName.toLowerCase().includes('gemini')) return 'Google';
    return 'Unknown Vendor';
}
// Show error message
function showError(message) {
    const categoriesGrid = document.getElementById('securityCategoriesGrid');
    if (categoriesGrid) categoriesGrid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: #dc2626; background: #fef2f2; border-radius: 8px; border: 1px solid #fecaca;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">\u{26A0}\u{FE0F} Assessment Data Unavailable</div>
                        <div style="font-size: 0.9rem;">${message}</div>
                    </div>
                `;
}
// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing security assessment...');
    // Check if this is a free version and update header accordingly
    const isFreeVersion = window.EMBEDDED_TOOL_INFO?.isFreeVersion || false;
    const subtitleElement = document.getElementById('reportSubtitle');
    if (isFreeVersion && subtitleElement) subtitleElement.innerHTML = 'Enterprise Security Analysis & Compliance Report<br><span style="background: rgba(255,255,255,0.2); padding: 0.25rem 0.75rem; border-radius: 1rem; font-size: 0.875rem; margin-top: 0.5rem; display: inline-block;">\uD83D\uDCC4 Free Version - Upgrade for detailed analysis</span>';
    loadSecurityAssessment();
});

</script>

<script src="/template-detailed.c9d12d22.js"></script></body></html>